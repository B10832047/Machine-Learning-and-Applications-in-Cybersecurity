import math, numpy, cv2, os
from PIL import Image

## markov
def get_markov(binary):
    # byte_frequency_table
    BFT = [[0 for j in range(256)] for i in range(256)]
    for i in range(len(binary)-1):
        BFT[binary[i]][binary[i+1]] += 1

    # byte_probability_table
    BPT = [[0 if sum(BFT[i])==0 else BFT[i][j]/sum(BFT[i]) for j in range(256)] for i in range(256)]

    markov_img = [[0 if max(BFT[i]) == min(BFT[i]) else (BPT[i][j] - min(BFT[i])) / (max(BFT[i]) - min(BFT[i])) for j in range(256)] for i in range(256)]
    #max_val = numpy.amax(markov_img)
    #markov_img = [[math.ceil(markov_img[i][j] / max_val) * 255 for j in range(256)] for i in range(256)]
    return numpy.array(markov_img)

## entropy
def get_entropy(binary):
    H = []
    for beg_i in range(0, len(binary), 128):
        # probability
        P = [0 for i in range(256)]
        end_i = min(beg_i + 128, len(binary))
        for i in range(beg_i, end_i):
            P[binary[i]] += 1
        P = [p / sum(P) for p in P]
        H += [round(-sum([(P[binary[i]])*math.log((P[binary[i]])) for i in range(beg_i, end_i)]))]

    row, col = max(H) - min(H) + 1, len(H)
    entropy_graph_img = [[0 for j in range(col)] for i in range(row)]
    for j in range(col):
        entropy_graph_img[H[j] - min(H)][j] = 1

    tmp_img = numpy.zeros([row, col, 3])
    tmp_img[:,:,0] = entropy_graph_img
    tmp_img[:,:,1] = entropy_graph_img
    tmp_img[:,:,2] = entropy_graph_img
    tmp_img = cv2.resize(tmp_img, (256, 256), interpolation=cv2.INTER_AREA)
    entropy_graph_img = numpy.array(tmp_img[:,:,0])
    return entropy_graph_img

## Gray-level matrix images
def get_gray_level(binary):
    grey_128 = numpy.array([[0 for j in range(256)] for i in range(256)])
    for i in range(len(binary)-1):
        grey_128[binary[i]][binary[i+1]] += 1

    max_freq = numpy.amax(numpy.array(grey_128))
    grey_128 = numpy.array([[math.ceil(grey_128[i][j] / max_freq * 128) for j in range(256)] for i in range(256)])

    glcm_0 = getGlcm(grey_128, 1, 0)  # 1,0 时为水平相邻：也就是0度时；
    glcm_45 = getGlcm(grey_128, 1, 1)  # 1,1 时为对角相邻，也就是45度时；
    glcm_90 = getGlcm(grey_128, 0, 1)  # 0,1 时为上下相邻，也就是90度时；
    glcm_135 = getGlcm(grey_128, -1, 1) # -1,1 时,即135度 ；

    GLCM_img = numpy.append(numpy.append(glcm_0, glcm_45, axis=1), numpy.append(glcm_90, glcm_135, axis=1), axis=0)
    #GLCM_img = numpy.array([[max(255, math.ceil(GLCM_img[i][j] * 255 * )) for j in range(256)] for i in range(256)])
    return GLCM_img

def getGlcm(input, d_x, d_y):
    srcdata = input.copy()
    ret = [[0.0 for i in range(128)] for j in range(128)]
    (height,width) = input.shape

    for j in range(max(0, 0 - d_y), min(height, height - d_y)):
        for i in range(max(0, 0 - d_x), min(width, width - d_x)):
            rows = min(127, srcdata[j][i])
            cols = min(127, srcdata[j + d_y][i + d_x])
            ret[rows][cols] += 1
    for i in range(128):
        for j in range(128):
            ret[i][j]/=float(height*width)

    return numpy.array(ret)

def binary_to_image(file_name):
    print(file_name)
    f = open(file_name, 'rb')
    binary = f.read()
    gem_image = numpy.zeros([256, 256, 3])
    gem_image[:,:,0] = get_markov(binary)
    gem_image[:,:,1] = get_entropy(binary)
    gem_image[:,:,2] = get_gray_level(binary)
    gem_image /= 255.0
    
    f.close()
    return gem_image


